###############################################################################
## GMusicTagger Project
##
## Copyright (C) 2011 Guillermo Guerrero g.guerrero.bus@gmail.com
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
##
## Python module ui/app.py
## Autogenerated from ui/glade/gmusictagger.glade
## Generated on Mon Dec 20 01:09:18 2010
##
## Warning: Do not modify any context comment such as #--
## They are required to keep user's code
###############################################################################

import os
import sys
import locale
import logging
import time
import shutil
import subprocess

import pygtk
pygtk.require('2.0')
import gtk

from SimpleGladeApp import SimpleGladeApp
from SimpleGladeApp import bindtextdomain

import core.env as env
from core.env import _
import core.preferences as preferences
import core.uriparser as uriparser

import ui.mp3tree as mp3tree
import ui.filechooser as filechooser
import ui.message as message
import ui.listmodel as listmodel
import ui.progressbar as progressbar
import ui.notifier as notifier
import ui.settings as settings


# Bind language on glade files
bindtextdomain(env.APP_NAME, env.I18N_PATH)

class GMusicTagger(SimpleGladeApp):
    """ Main controller for the GMusicTagger GUI """

    ###########################################################################    
    ## Intialize Methods
    
    def __init__(self, path="ui/glade/gmusictagger.glade",
                 root="GMusicTagger",
                 domain=env.APP_NAME,
                 **kwargs):
        """ Intialize the Glade Files and the extra Widget.
        Also initialize the log, the core helpers and the text domain """        
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)             
        
        # Set Application Icon
        self.GMusicTagger.set_icon_from_file(env.ICON_GMUSICTAGGER)
        
        # Set menu icons
        self.image_add.set_from_pixbuf(env.ADD_BUF32)
        self.image_remove.set_from_pixbuf(env.REMOVE_BUF32)
        self.image_update.set_from_pixbuf(env.UPDATE_BUF32)
        self.image_fill.set_from_pixbuf(env.FILL_BUF32)
        self.image_play.set_from_pixbuf(env.PLAY_BUF32)
        self.image_settings.set_from_pixbuf(env.SETTINGS_BUF32)
        
        self.image_export_apic.set_from_pixbuf(env.EXPORT_APIC_BUF16)
        self.image_remove_apic.set_from_pixbuf(env.REMOVE_APIC_BUF16)
        
        self.image_mp3_up.set_from_pixbuf(env.ARROW_UP_BUF16)
        self.image_mp3_down.set_from_pixbuf(env.ARROW_DOWN_BUF16)
        self.image_edited_mp3.set_from_pixbuf(env.EDITED_TRACK_BUF24)
        
        # Load preferences in config        
        config_file = os.path.join(env.CONFIG_PATH,env.CONFIG_FILE)
        self.prefparser = preferences.Config(config_file) 
        self.config = self.prefparser.load()                                              

        # Initialize log
        self.initialize_log()
        self.log = logging.getLogger(self.__class__.__name__)
        self.log.info("%s %s" % (env.APP_NAME,env.APP_VERSION))
        self.log.info("Session started")
               
        # Initialize ProgressBar
        self.progressbarbox = progressbar.ProgressBarBox()                                    
        self.vbox_buttons.pack_end(self.progressbarbox)
                
        # Initialize Mp3 Tree
        self.initialize_mp3_tree()            

        # Initialize Cover
        self.mp3_apic.set_from_pixbuf(env.EMPTY_APIC_BUF160)
        self.btn_apic.set_sensitive(False)
        self.btn_export_apic.set_sensitive(False)
        self.btn_remove_apic.set_sensitive(False)

        # Initialize Generic Tagging
        self.generic_tag_cover = None
        self.generic_tag_mode_active = False
        self.initialize_generic_tagging()
        self.update_generic_tagging_view()
        
        # Initialize the settings dialog
        settingsglade = os.path.join(env.GLADE_PATH,env.GLADE_SETTINGS)
        self.dialog_settings = settings.DialogSettings(path=settingsglade)        
        
    def initialize_log(self):
        mystream = logging.StreamHandler()
        logging.basicConfig(level=self.config['log']['level'],
                            format=self.config['log']['format'],
                            datefmt=self.config['log']['datetime'],
                            filename=os.path.join(self.config['log']['path'],self.config['log']['name']),
                            filemode=self.config['log']['mode'],
                            stream=mystream)   

    def initialize_mp3_tree(self):
        """ Initialize all about the Mp3 Tree """
        # Add MP3 Tree 
        self.mp3_tree = mp3tree.Mp3Tree(self.config) 
        self.scrolledwindow_mp3tree.add(self.mp3_tree)
        
        # Connect the 'cursor-changed' signal to show the APIC
        self.mp3_tree.connect('cursor-changed',
                              self.flush_active_row_mp3_apic)
        
        # Share main objects
        self.mp3_tree.share_attributes(cbtn_selectall = self.cbtn_selectall,
                                       progressbarbox = self.progressbarbox)
 
         # Drag and Drop on the treeview
        dnd_targets = [('text/plain', 0, 1)]
                            
        self.mp3_tree.enable_model_drag_dest(dnd_targets,
                                             gtk.gdk.ACTION_DEFAULT)
                                                              
        self.mp3_tree.connect("drag_data_received",
                              self.drag_data_received_data) 
                                      
    def initialize_generic_tagging(self):
        """ Initialize all about the generic tag mode """
        # Set Year SpinButton
        self.spinbutton_year = gtk.SpinButton()
        self.spinbutton_year.set_digits(0)
        year = int(time.strftime('%Y',time.localtime()))
        self.spinbutton_year.set_range(year-150,year+20)
        self.spinbutton_year.set_value(year)
        self.spinbutton_year.set_numeric(True)
        self.spinbutton_year.set_increments(1,1)
        self.spinbutton_year.show()
        self.hbox_generic_tag_TYER.pack_start(self.spinbutton_year)
        
        # Set Genre Combobox
        self.genre_model = listmodel.GenreListStore()        
        self.cmbentry_genre = gtk.ComboBoxEntry(self.genre_model,0)
        genre_tooltip = _("Select the genre from the list or type your own")
        self.cmbentry_genre.set_tooltip_markup(genre_tooltip)
        self.cmbentry_genre.show()
        self.hbox_generic_tag_TCON.pack_start(self.cmbentry_genre)
        
        # Set Filename Combobox
        self.filename_model = listmodel.FilenameListStore() 
        self.cmbentry_filename = gtk.ComboBoxEntry(self.filename_model,0)
        filename_tooltip = _("""Modify the <i>mp3</i> filename combining the
frame markups (%artist,%title,%album and %trck) or 
by selecting a preconfigured template from the list bellow""")
        self.cmbentry_filename.set_tooltip_markup(filename_tooltip)
        self.cmbentry_filename.show()
        self.hbox_generic_tag_FILE.pack_start(self.cmbentry_filename)
        
        if self.config["generic-tag"]["active-at-start"]:
            self.on_btn_generic_tag_clicked(self.btn_generic_tag)
        
    def update_generic_tagging_view(self):
        """
        Review each generic tag block to set sesitive = False if it correspondent
        column on the tree is not visible
        """
        try:
            for col_id in env.COLUMN_IDS:
                frame_widget = self.get_widget("hbox_generic_tag_" + col_id)
                if (frame_widget):
                    # Reset the fram visible/sensitve property to True, then re-hide it
                    frame_widget.set_property('visible', True)
                    frame_widget.set_property('sensitive', True)
                    
                    column_is_visible = self.config[col_id]['visible']
                    frame_widget.set_property(self.config["generic-tag"]["hide-frame-property"],
                                              column_is_visible)
        except:
            self.log.exception("Error setting generic tag view")
            
    ###########################################################################
    
    
    ###########################################################################        
    ## Program Exit Methods
                        
    def on_GMusicTagger_destroy(self, widget, *args):
        """ Exit the program and shutdown the logger stream """
        self.gtk_main_quit()
        if os.path.exists(env.TEMP_APIC_PATH): os.remove(env.TEMP_APIC_PATH)
        self.log.info("Session closed")
        logging.shutdown() 

    def on_GMusicTagger_delete_event(self, widget, *args):
        """ Check if one or more files are pending to be updated.
        Then, ask to the user for cancel or continue exiting the program """
        stop_exit = False        
        if self.mp3_tree.is_any_pending_to_update():
            self.log.warning("Some files still pending for update. Continue?")
            user_answer = message.question(_("Exiting..."),
                                           _("Some files are pending to update. Continue exiting?"),
                                           self.GMusicTagger)
            if not user_answer:
                stop_exit = True
                
        return stop_exit
    
    ###########################################################################
    
    
    ###########################################################################
    ## Append Mp3 Items Methods
    
    def drag_data_received_data(self, treeview, context, x, y, selection, info, etime):
        """ Drop data received. Handle it """
        self.log.info("Drag data received")
        
        model = treeview.get_model()
        drop_info = treeview.get_dest_row_at_pos(x, y)
        dropped_mp3files = uriparser.get_mp3_files_from_uri_data(selection.data)
        
        if len(dropped_mp3files) > 0:
            # Append the new files in the tree
            self.lock_app()
            total_added = self.mp3_tree.add_iters(dropped_mp3files) 
            self.unlock_app()
            
            # Show finish notification
            if total_added and self.config['misc']['show-notifications']:
                notifier.show_notification(_("Load complete"),
                                           "%03d %s" %(total_added,
                                                     _("MP3 files added...")))
                          
                          
    def on_btn_add_clicked(self, widget, *args):
        """ Open a FileChooserDialog and gets the 
        selected Mp3 files from it """
        self.log.info("Showing the open files dialog")        
        
        # Opens the mp3 files selection dialog
        selected_mp3files = filechooser.selectMp3Files(self.GMusicTagger,
                                                       self.config['music']['start-folder'])                  
        
        if len(selected_mp3files) > 0:
            # Append the new files in the tree
            self.lock_app()
            total_added = self.mp3_tree.add_iters(selected_mp3files)
            self.unlock_app()
            
            # Show finish notification
            if total_added and self.config['misc']['show-notifications']:
                notifier.show_notification(_("Load complete"),
                                           "%03d %s" %(total_added,
                                                     _("MP3 files added...")))                                     
        
    ###########################################################################


    ###########################################################################
    ## Lock/Unlock GUI methods
    def lock_app(self):
        """
        """
        self.hbox_buttons.set_sensitive(False)
        self.hbox_apic.set_sensitive(False)
        self.frame_generic_tag.set_sensitive(False)
        self.frame_mp3tree.set_sensitive(False)
        while gtk.events_pending(): gtk.main_iteration()
    
    def unlock_app(self):
        """
        """
        self.hbox_buttons.set_sensitive(True)
        self.hbox_apic.set_sensitive(True)
        self.frame_generic_tag.set_sensitive(True)
        self.frame_mp3tree.set_sensitive(True)
        while gtk.events_pending(): gtk.main_iteration()
        
            
    ###########################################################################
    

    ###########################################################################
    ## Remove Mp3 Items Methods
    
    def on_btn_remove_clicked(self, widget, *args):
        """ Clear the selected files in the tree.
        Also remove them from the core """
        self.log.info("Clearing the selected files in the tree/core")
                
        # Get selected filenames
        selected_mp3_files = self.mp3_tree.get_selected_mp3_files()
        
        # If some of them are pending to update, ask the user what to do
        selected_pending_to_update = self.mp3_tree.pending_files_to_update(selected_mp3_files)
        remove_them = False
        if len(selected_pending_to_update) > 0:
            user_answer = message.question(_("Cleaning mp3 files"),
                                           _("Some selected <i>mp3</i> files are pending to update. Clean selected files anyway?"),
                                           self.GMusicTagger)
            if user_answer:
                remove_them = True
        else:
            remove_them = True
        
        # Finally if all agree, remove the selected files                                                           
        if remove_them:
            self.mp3_tree.remove_selected_iters()
            
            # Refresh the row APIC
            self.flush_active_row_mp3_apic()

    ###########################################################################           
             
    
    ###########################################################################
    ## Miscellaneous Methods

    def on_btn_update_clicked(self, widget, *args):
        """
        Retrieve the selected tracks on the tree and update the mp3 tag of each
        one. Also rename the file if the column 'file' has been changed.
        """
        self.lock_app()
        total_updated = self.mp3_tree.update_selected_iters()
        self.unlock_app()
        
        # Show finish notification
        if total_updated and self.config['misc']['show-notifications']:
            notifier.show_notification(_("Update complete"),
                                       "%03d %s" % (total_updated,
                                                  _("MP3 files updated...")))       
                
    def on_btn_play_clicked(self, btn_play):
        """
        Get the seletect tracks on the tree and play them with the defined
        mp3 player (default 'totem')        
        """
        title = _("Music player")
        try:
            self.log.info("Play selected tracks")
            selected_track_list = self.mp3_tree.get_selected_mp3_files()
            selected_tracks = ''
            if len(selected_track_list) > 0:
                selected_tracks = '"' + '" "'.join(selected_track_list) + '"'        
            play_command = "%s %s" % (self.config['music']['player'],
                                        selected_tracks)
                                        
            process = subprocess.Popen(play_command,
                                       shell = True,
                                       stdout = subprocess.PIPE,
                                       stderr = subprocess.PIPE)
                                       
            # Wait a bit to kwnon if the process failed inmediatily
            time.sleep(0.2)
            returncode = process.poll()
            if returncode:                
                error_message = _("Cannot open music player:\n\n")
                stdout = ''.join(process.stdout.readlines()).replace("&","&amp;")
                stderr = ''.join(process.stderr.readlines()).replace("&","&amp;")
                error_message = "%s%s%s" % (error_message, stdout, stderr)
                message.error(title, error_message, self.GMusicTagger)
        except:
            self.log.exception("Error running music player")
            exception_message = _("Error running music player")
            message.exception(title, exception_message, self.GMusicTagger)
            
    def on_btn_settings_clicked(self, widget, *args):
        """
        Run the dialog settings and get the new config
        """
        self.dialog_settings.set_config(self.config)
        new_config = self.dialog_settings.run()
        
        if (self.config != new_config):
            self.log.info("Settings changes, updating app configuration")
            self.config = new_config
            self.mp3_tree.update_properties(new_config)
            self.update_generic_tagging_view()
            
            self.prefparser.save(new_config)      
            
    ###########################################################################  
    

    ###########################################################################  
    ## All cover methods (Include the 'cursor-changed' for the Mp3 Tree)

    def flush_active_row_mp3_apic(self, treeview=None):
        """
        The main scope of this method is to perform an action when the treeview
        signal 'cursor-changed' is emitted. This action is to refresh the APIC
        widget with the new tree row that is active.
        But also this method is called any time we need to refresh the APIC
        widget.
        Is needed to recieve the treeview as a param because this method is
        connected to the 'cursor-changed' signal of the tree. 
        """
        self.log.debug("Sets APIC on active tree row")
        if not treeview: treeview = self.mp3_tree        
        is_any_row_active = self.mp3_tree.is_any_row_active()
        
        # Refresh the Mp3 APIC
        if not self.generic_tag_mode_active:
            if is_any_row_active:
                self.btn_apic.set_sensitive(True)
                
                mp3_apic_pixbuf = self.mp3_tree.get_active_row_mp3_apic()
                if mp3_apic_pixbuf:            
                    self.mp3_apic.set_from_pixbuf(mp3_apic_pixbuf)
                    
                    self.btn_export_apic.set_sensitive(True)
                    self.btn_remove_apic.set_sensitive(True)
                else:
                    self.mp3_apic.set_from_pixbuf(env.EMPTY_APIC_BUF160)
                    self.btn_export_apic.set_sensitive(False)
                    self.btn_remove_apic.set_sensitive(False)           
            else:
                self.mp3_apic.set_from_pixbuf(env.EMPTY_APIC_BUF160)
                self.btn_apic.set_sensitive(False)
                self.btn_export_apic.set_sensitive(False)
                self.btn_remove_apic.set_sensitive(False)
                
       
        # Refresh the Mp3 Update Tooltip
        if is_any_row_active:
            mp3 = self.mp3_tree.get_active_row_mp3_path()
            self.show_mp3_update_tooltip_if(mp3)
        else:
            self.show_mp3_update_tooltip_if()
                        
    def load_apic_from_file(self, filename):
        """
        Create a scaled Pixbuf and add it to the apic image widget
        """
        pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(filename,
                                                      env.APIC_WIDTH,
                                                      env.APIC_HEIGHT)
        self.mp3_apic.set_from_pixbuf(pixbuf)
                                                        
    def on_btn_apic_cover_clicked(self, widget, *args):
        """
        Sets a new cover file if a file is selected
        """
        selected_cover = filechooser.selectCoverFile(self.GMusicTagger,
                                                     self.config['cover']['start-folder'])
        
        if selected_cover:           
            self.log.info("New cover selected %s" % selected_cover)
            
            # If generic tag mode is not active then 
            # apply the cover on the selected mp3 row
            if not self.generic_tag_mode_active:
                self.mp3_tree.set_apic_on_active_row_mp3(selected_cover)   
            
                # Refresh the row seleted APIC Buffer
                self.flush_active_row_mp3_apic()
                  
            # If generic tag mode is active then 
            # store the selected file name
            else:        
                # Show the new selected Cover
                self.load_apic_from_file(selected_cover)
                self.btn_export_apic.set_sensitive(True)
                self.btn_remove_apic.set_sensitive(True)
                
                # Save the selected Cover Path         
                self.generic_tag_cover = selected_cover
                    
    def on_btn_export_apic_clicked(self, btn_export_apic):
        """
        Export the actual image on the APIC button as a file
        """
        if not self.generic_tag_mode_active:
            apic_filename = self.mp3_tree.get_active_row_mp3_apic_filename()
            cover_filename = filechooser.saveCoverFileAs(self.GMusicTagger,
                                                         filename=apic_filename)                                         
            if cover_filename:
                try:
                    self.mp3_tree.export_active_row_mp3_apic_as(cover_filename)
                    self.log.info("Cover exported as %s" % cover_filename)                            
                except:
                    self.log.exception("Cannot export APIC")
            else:
                self.log.info("Cover export Cancelled")            
        else:
            apic_filename = os.path.basename(self.generic_tag_cover)        
            cover_filename = filechooser.saveCoverFileAs(self.GMusicTagger,
                                                         filename=apic_filename)                                         
            if cover_filename:
                try:
                    shutil.copy(self.generic_tag_cover,cover_filename)                
                    self.log.info("Cover exported as %s" % cover_filename)                
                except:
                    self.log.exception("Cannot export APIC")
            else:
                self.log.info("Cover export Cancelled")
                

    def on_btn_remove_apic_clicked(self, widget, *args):
        """
        Clean the APIC Buffer and the Mp3 APIC.
        Delete the APIC from the Mp3 selected file if generic tag mode is
        not active.
        """
        if not self.generic_tag_mode_active:
            self.mp3_tree.remove_appic_from_active_row_mp3()
            self.flush_active_row_mp3_apic()
        else:
            self.mp3_apic.set_from_pixbuf(env.EMPTY_APIC_BUF160)
            self.btn_export_apic.set_sensitive(False)
            self.btn_remove_apic.set_sensitive(False)  
            self.generic_tag_cover = None
    
    ###########################################################################  
        

    ###########################################################################
    ## Generic tagging methods
    
    def on_btn_generic_tag_clicked(self, widget, *args):
        """ Turns on/off the Generic Tagging mode """
        if self.generic_tag_mode_active:
            self.btn_fill.set_sensitive(False)
            self.arrow_generic_tag.set_property("arrow-type",gtk.ARROW_RIGHT)
            self.vbox_generic_tag.set_property('visible',False)
            self.cbtn_apic.set_property('visible',False)
            self.generic_tag_mode_active = False
            
            self.flush_active_row_mp3_apic()
        else:
            self.btn_fill.set_sensitive(True)
            self.arrow_generic_tag.set_property("arrow-type",gtk.ARROW_DOWN)
            self.vbox_generic_tag.set_property('visible',True)
            self.cbtn_apic.set_property('visible',True)
            self.generic_tag_mode_active = True            
                
            self.flush_generic_tag_cover()
    
    def flush_generic_tag_cover(self):
        """
        Show up the generic tag cover if exists.
        Show up the cover buttons as the generic tag mode can use them
        """
        
        self.btn_apic.set_sensitive(True)
        if self.generic_tag_cover:
            self.load_apic_from_file(self.generic_tag_cover)
            self.btn_export_apic.set_sensitive(True)
            self.btn_remove_apic.set_sensitive(True)
        else:
            self.mp3_apic.set_from_pixbuf(env.EMPTY_APIC_BUF160)
            self.btn_export_apic.set_sensitive(False)
            self.btn_remove_apic.set_sensitive(False) 

    def on_btn_fill_clicked(self, widget, *args):
        """
        Apply the selected generic tag frames to the selected files on the tree
        """
        self.log.debug("Apply generic tag button clicked")
        
        apply_generic_tag = message.question(_("Apply generic tag"),
                                             _("The generic tag is going to be applied on all the <i>mp3</i> files selected. Are you sure?"),
                                             self.GMusicTagger)
        if apply_generic_tag:
            self.log.info("Applying the selected generic tag frames")
                        
            generic_tag_values = self.get_generic_tag_frame_values()
            self.mp3_tree.apply_generic_tag_on_selected(generic_tag_values)


    def get_generic_tag_frame_values(self):
        """
        Extract all the values from the active (sensitive and checked) frames
        on the generic tag block
        """

        # Frames dictionary with all the Values
        frame_values = {}        
        
        # Frame APIC: Attached Picture
        if self.cbtn_apic.get_active():
            frame_values['APIC'] = self.generic_tag_cover
                   
        # Frame TIT2:  Title
        frame_is_not_hide = self.hbox_generic_tag_TIT2.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_title.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TIT2'] = self.entry_title.get_text()
            
        # Frame TPE1:  Artist
        frame_is_not_hide = self.hbox_generic_tag_TPE1.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_artist.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TPE1'] = self.entry_artist.get_text()
            
        # Frame TPE2:  Band
        frame_is_not_hide = self.hbox_generic_tag_TPE2.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_band.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TPE2'] = self.entry_band.get_text()
            
        # Frame TPE3:  Performer
        frame_is_not_hide = self.hbox_generic_tag_TPE3.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_performer.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TPE3'] = self.entry_performer.get_text()
            
        # Frame TPE4:  Remix
        frame_is_not_hide = self.hbox_generic_tag_TPE4.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_remix.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TPE4'] = self.entry_remix.get_text()

        # Frame TCOM:  Composer
        frame_is_not_hide = self.hbox_generic_tag_TCOM.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_composer.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TCOM'] = self.entry_composer.get_text()

        # Frame TALB:  Album
        frame_is_not_hide = self.hbox_generic_tag_TALB.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_album.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TALB'] = self.entry_album.get_text()

        # Frame TALB:  Album
        frame_is_not_hide = self.hbox_generic_tag_TALB.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_album.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TALB'] = self.entry_album.get_text()                           
        
        # Frame TYER:  Year
        frame_is_not_hide = self.hbox_generic_tag_TYER.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_year.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TYER'] = str(self.spinbutton_year.get_value_as_int())
         
        # Frame TCON:  Genre
        frame_is_not_hide = self.hbox_generic_tag_TCON.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_genre.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['TCON'] = self.cmbentry_genre.get_active_text()         
                    
        # Frame COMM:  Comments
        frame_is_not_hide = self.hbox_generic_tag_COMM.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_comments.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['COMM'] = self.entry_comments.get_text()                    

        # Frame FILE: Mp3 Filename
        frame_is_not_hide = self.hbox_generic_tag_FILE.get_property(self.config["generic-tag"]["hide-frame-property"])
        frame_is_active = self.cbtn_filename.get_active()
        if frame_is_not_hide and frame_is_active:
            frame_values['FILE'] = self.cmbentry_filename.get_active_text()
        
        # Frame TRCK: Tracknum (Create Sequence && Delete Tracknum)
        frame_is_not_hide = self.hbox_generic_tag_TRCK.get_property(self.config["generic-tag"]["hide-frame-property"])
        if frame_is_not_hide:
            frame_values['TRCKSEQ'] = self.cbtn_tracknum_create_sequence.get_active()
            frame_values['DELTRCK'] = self.cbtn_tracknum_delete.get_active()                
                
        # Compact Artist tag (Delete Band, Performer, Remix and Composer)
        frame_values['COMPACT'] = self.cbtn_compact_artist_tag.get_active()
        
        return frame_values
                          
    ###########################################################################  


    ###########################################################################    
    ## Mp3 Tree extra buttons
    def on_cbtn_selectall_toggled(self, cbtn_selectall):
        """ 
        Select or unselect all the mp3 files stored the tree.
        This method has the toggle button state updated.        
        """
        self.log.debug("Select all button toggled")

        if cbtn_selectall.get_inconsistent():
            cbtn_selectall.set_inconsistent(False)
        else:            
            if cbtn_selectall.get_active():
                self.mp3_tree.select_all()
            else:
                self.mp3_tree.unselect_all()
                                        
    def on_btn_mp3_up_clicked(self, btn_mp3_up):
        """
        Moves the selected Mp3 Tree line up
        """
        self.mp3_tree.move_track_up()
              
    def on_btn_mp3_down_clicked(self, btn_mp3_down):
        """
        Moves the selected Mp3 Tree line down
        """ 
        self.mp3_tree.move_track_down()

    def show_mp3_update_tooltip_if(self,mp3 = None):
        """ If the Mp3 path is pending to be update the show the save markup """
        
        tooltip_text = _("The Mp3 file <b><i>%s</i></b> was modified. Update it.") % mp3
        tooltip_text = tooltip_text.replace("&","&amp;")
        if mp3 and self.mp3_tree.pending_to_update(mp3):
            self.image_edited_mp3.set_property('visible',True)            
            self.image_edited_mp3.set_tooltip_markup(tooltip_text)
        else:
            self.image_edited_mp3.set_property('visible',False)
            
    ###########################################################################
    
